/* 
 * @(#)Device.java        1.0 19/01/15
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "device-management", revision: "2014-07-26".
 */

package net.juniper.yang.mo.deviceManagement;

import com.tailf.jnc.Element;
import com.tailf.jnc.ElementChildrenIterator;
import com.tailf.jnc.ElementLeafListValueIterator;
import com.tailf.jnc.JNCException;
import com.tailf.jnc.Leaf;
import com.tailf.jnc.NodeSet;
import com.tailf.jnc.Tagpath;
import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangEnumeration;
import com.tailf.jnc.YangString;

import net.juniper.yang.mo.deviceManagement.device.ActiveConfigurations;
import net.juniper.yang.mo.deviceManagement.device.AssociatedScripts;
import net.juniper.yang.mo.deviceManagement.device.ChangeLogs;
import net.juniper.yang.mo.deviceManagement.device.ConfigInfo;
import net.juniper.yang.mo.deviceManagement.device.IdPerms;
import net.juniper.yang.mo.deviceManagement.device.Inventory;
import net.juniper.yang.mo.deviceManagement.device.JInterface;
import net.juniper.yang.mo.deviceManagement.device.LicenseUsageSummary;
import net.juniper.yang.mo.deviceManagement.device.LsysInfo;
import net.juniper.yang.mo.deviceManagement.device.MgtConnection;
import net.juniper.yang.mo.deviceManagement.device.OobChanges;
import net.juniper.yang.mo.deviceManagement.device.Partitions;
import net.juniper.yang.mo.deviceManagement.device.Redundancy;
import net.juniper.yang.mo.deviceManagement.device.ScriptExecutionHistories;
import net.juniper.yang.mo.deviceManagement.device.Softwares;
import net.juniper.yang.mo.deviceManagement.device.StagedImages;
import net.juniper.yang.mo.deviceManagement.device.System;
import net.juniper.yang.mo.deviceManagement.device.Templates;
import net.juniper.yang.mo.ietfInetTypes.Uri;
import net.juniper.yang.mo.ietfYangTypes.Uuid;
import net.juniper.yang.mo.iqIfmapTypes.Ifmap;

/**
 * This class represents an element from 
 * the namespace http://juniper.net/ns/space/device-management/1.0
 * generated to "/home/maxin/space/js-ems/server/target/scala-2.11/src_managed/main/net/juniper/yang/mo/deviceManagement/device"
 * <p>
 * See line 235 in
 * /home/maxin/space/js-ems/server/src/main/resources/yang/device-management.yang
 *
 * @version 1.0 2015-01-19
 * @author Auto Generated
 */
public class Device extends YangElement {

    private static final long serialVersionUID = 1L;

    public static final Tagpath TAG_PATH = new Tagpath("device");

    static {
        Devicemgt.enable();
    }

    /**
     * Field for child container "id-perms".
     */
    public IdPerms idPerms = null;

    /**
     * Field for child container "system".
     */
    public System system = null;

    /**
     * Field for child container "lsysInfo".
     */
    public LsysInfo lsysInfo = null;

    /**
     * Field for child container "redundancy".
     */
    public Redundancy redundancy = null;

    /**
     * Field for child container "configInfo".
     */
    public ConfigInfo configInfo = null;

    /**
     * Field for child container "mgtConnection".
     */
    public MgtConnection mgtConnection = null;

    /**
     * Constructor for an empty Device object.
     */
    public Device() {
        super(Devicemgt.NAMESPACE, "device");
        setDefaultPrefix();
        setPrefix(Devicemgt.PREFIX);
    }

    /**
     * Constructor for an initialized Device object,
     * 
     * @param uuidValue Key argument of child.
     */
    public Device(Uuid uuidValue) throws JNCException {
        super(Devicemgt.NAMESPACE, "device");
        setDefaultPrefix();
        setPrefix(Devicemgt.PREFIX);
        Leaf uuid = new Leaf(Devicemgt.NAMESPACE, "uuid");
        uuid.setValue(uuidValue);
        insertChild(uuid, childrenNames());
    }

    /**
     * Constructor for an initialized Device object,
     * with String keys.
     * @param uuidValue Key argument of child.
     */
    public Device(String uuidValue) throws JNCException {
        super(Devicemgt.NAMESPACE, "device");
        setDefaultPrefix();
        setPrefix(Devicemgt.PREFIX);
        Leaf uuid = new Leaf(Devicemgt.NAMESPACE, "uuid");
        uuid.setValue(new Uuid(uuidValue));
        insertChild(uuid, childrenNames());
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public Device clone() {
        Device copy;
        try {
            copy = new Device(getUuidValue().toString());
        } catch (JNCException e) {
            copy = null;
        }
        return (Device)cloneContent(copy);
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public Device cloneShallow() {
        Device copy;
        try {
            copy = new Device(getUuidValue().toString());
        } catch (JNCException e) {
            copy = null;
        }
        return (Device)cloneShallowContent(copy);
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return new String[] {
            "uuid",
        };
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "administrative-domain",
            "name",
            "type",
            "other-definition",
            "fq-name",
            "uuid",
            "href",
            "parent-uuid",
            "parent-href",
            "parent-type",
            "display-name",
            "id-perms",
            "deviceType",
            "system",
            "lsysInfo",
            "redundancy",
            "configInfo",
            "mgtConnection",
            "interface",
            "inventory",
            "activeConfigurations",
            "templates",
            "oobChanges",
            "changeLogs",
            "associatedScripts",
            "scriptExecutionHistories",
            "partitions",
            "stagedImages",
            "softwares",
            "licenseUsageSummary",
        };
    }

    /* Access methods for optional leaf child: "administrative-domain". */

    /**
     * Gets the value for child leaf "administrative-domain".
     * @return The value of the leaf.
     */
    public YangString getAdministrativeDomainValue() throws JNCException {
        return (YangString)getValue("administrative-domain");
    }

    /**
     * Sets the value for child leaf "administrative-domain",
     * using instance of generated typedef class.
     * @param administrativeDomainValue The value to set.
     * @param administrativeDomainValue used during instantiation.
     */
    public void setAdministrativeDomainValue(YangString administrativeDomainValue)
            throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "administrative-domain",
            administrativeDomainValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "administrative-domain",
     * using a String value.
     * @param administrativeDomainValue used during instantiation.
     */
    public void setAdministrativeDomainValue(String administrativeDomainValue)
            throws JNCException {
        setAdministrativeDomainValue(new YangString(administrativeDomainValue));
    }

    /**
     * Unsets the value for child leaf "administrative-domain".
     */
    public void unsetAdministrativeDomainValue() throws JNCException {
        delete("administrative-domain");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "administrative-domain" leaf will not have a value.
     */
    public void addAdministrativeDomain() throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "administrative-domain",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "administrative-domain" with operation "replace".
     */
    public void markAdministrativeDomainReplace() throws JNCException {
        markLeafReplace("administrativeDomain");
    }

    /**
     * Marks the leaf "administrative-domain" with operation "merge".
     */
    public void markAdministrativeDomainMerge() throws JNCException {
        markLeafMerge("administrativeDomain");
    }

    /**
     * Marks the leaf "administrative-domain" with operation "create".
     */
    public void markAdministrativeDomainCreate() throws JNCException {
        markLeafCreate("administrativeDomain");
    }

    /**
     * Marks the leaf "administrative-domain" with operation "delete".
     */
    public void markAdministrativeDomainDelete() throws JNCException {
        markLeafDelete("administrativeDomain");
    }

    /* Access methods for optional leaf child: "name". */

    /**
     * Gets the value for child leaf "name".
     * @return The value of the leaf.
     */
    public YangString getNameValue() throws JNCException {
        return (YangString)getValue("name");
    }

    /**
     * Sets the value for child leaf "name",
     * using instance of generated typedef class.
     * @param nameValue The value to set.
     * @param nameValue used during instantiation.
     */
    public void setNameValue(YangString nameValue) throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "name",
            nameValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "name",
     * using a String value.
     * @param nameValue used during instantiation.
     */
    public void setNameValue(String nameValue) throws JNCException {
        setNameValue(new YangString(nameValue));
    }

    /**
     * Unsets the value for child leaf "name".
     */
    public void unsetNameValue() throws JNCException {
        delete("name");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "name" leaf will not have a value.
     */
    public void addName() throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "name",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "name" with operation "replace".
     */
    public void markNameReplace() throws JNCException {
        markLeafReplace("name");
    }

    /**
     * Marks the leaf "name" with operation "merge".
     */
    public void markNameMerge() throws JNCException {
        markLeafMerge("name");
    }

    /**
     * Marks the leaf "name" with operation "create".
     */
    public void markNameCreate() throws JNCException {
        markLeafCreate("name");
    }

    /**
     * Marks the leaf "name" with operation "delete".
     */
    public void markNameDelete() throws JNCException {
        markLeafDelete("name");
    }

    /* Access methods for optional leaf child: "type". */

    /**
     * Gets the value for child leaf "type".
     * @return The value of the leaf.
     */
    public YangEnumeration getTypeValue() throws JNCException {
        return (YangEnumeration)getValue("type");
    }

    /**
     * Sets the value for child leaf "type",
     * using instance of generated typedef class.
     * @param typeValue The value to set.
     * @param typeValue used during instantiation.
     */
    public void setTypeValue(YangEnumeration typeValue) throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "type",
            typeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "type",
     * using a String value.
     * @param typeValue used during instantiation.
     */
    public void setTypeValue(String typeValue) throws JNCException {
        setTypeValue(new YangEnumeration(typeValue, new String[] {
             "aik-name",
             "distinguished-name",
             "dns-name",
             "email-address",
             "hip-hit",
             "kerberos-principal",
             "username",
             "sip-uri",
             "tel-uri",
             "other",
        }));
    }

    /**
     * Unsets the value for child leaf "type".
     */
    public void unsetTypeValue() throws JNCException {
        delete("type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "type" leaf will not have a value.
     */
    public void addType() throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "type" with operation "replace".
     */
    public void markTypeReplace() throws JNCException {
        markLeafReplace("type");
    }

    /**
     * Marks the leaf "type" with operation "merge".
     */
    public void markTypeMerge() throws JNCException {
        markLeafMerge("type");
    }

    /**
     * Marks the leaf "type" with operation "create".
     */
    public void markTypeCreate() throws JNCException {
        markLeafCreate("type");
    }

    /**
     * Marks the leaf "type" with operation "delete".
     */
    public void markTypeDelete() throws JNCException {
        markLeafDelete("type");
    }

    /* Access methods for optional leaf child: "other-definition". */

    /**
     * Gets the value for child leaf "other-definition".
     * @return The value of the leaf.
     */
    public YangString getOtherDefinitionValue() throws JNCException {
        return (YangString)getValue("other-definition");
    }

    /**
     * Sets the value for child leaf "other-definition",
     * using instance of generated typedef class.
     * @param otherDefinitionValue The value to set.
     * @param otherDefinitionValue used during instantiation.
     */
    public void setOtherDefinitionValue(YangString otherDefinitionValue)
            throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "other-definition",
            otherDefinitionValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "other-definition",
     * using a String value.
     * @param otherDefinitionValue used during instantiation.
     */
    public void setOtherDefinitionValue(String otherDefinitionValue)
            throws JNCException {
        setOtherDefinitionValue(new YangString(otherDefinitionValue));
    }

    /**
     * Unsets the value for child leaf "other-definition".
     */
    public void unsetOtherDefinitionValue() throws JNCException {
        delete("other-definition");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "other-definition" leaf will not have a value.
     */
    public void addOtherDefinition() throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "other-definition",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "other-definition" with operation "replace".
     */
    public void markOtherDefinitionReplace() throws JNCException {
        markLeafReplace("otherDefinition");
    }

    /**
     * Marks the leaf "other-definition" with operation "merge".
     */
    public void markOtherDefinitionMerge() throws JNCException {
        markLeafMerge("otherDefinition");
    }

    /**
     * Marks the leaf "other-definition" with operation "create".
     */
    public void markOtherDefinitionCreate() throws JNCException {
        markLeafCreate("otherDefinition");
    }

    /**
     * Marks the leaf "other-definition" with operation "delete".
     */
    public void markOtherDefinitionDelete() throws JNCException {
        markLeafDelete("otherDefinition");
    }

    /* Access methods for optional leaf-list child: "fq-name". */

    /**
     * Iterator method for the leaf-list "fq-name".
     * @return An iterator for the leaf-list.
     */
    public ElementLeafListValueIterator fqNameIterator() {
        return new ElementLeafListValueIterator(children, "fq-name");
    }

    /**
     * Sets the value for child leaf-list "fq-name",
     * using instance of generated typedef class.
     * @param fqNameValue The value to set.
     * @param fqNameValue used during instantiation.
     */
    public void setFqNameValue(YangString fqNameValue) throws JNCException {
        setLeafListValue(Ifmap.NAMESPACE,
            "fq-name",
            fqNameValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf-list "fq-name",
     * using a String value.
     * @param fqNameValue used during instantiation.
     */
    public void setFqNameValue(String fqNameValue) throws JNCException {
        setFqNameValue(new YangString(fqNameValue));
    }

    /**
     * Deletes leaf-list entry "fqName".
     * @param fqNameValue Value to delete.
     */
    public void deleteFqName(YangString fqNameValue) throws JNCException {
        String path = "fqName[fqNameValue]";
        delete(path);
    }

    /**
     * Deletes leaf-list entry "fqName".
     * The value is specified as a string.
     * @param fqNameValue Value to delete.
     */
    public void deleteFqName(String fqNameValue) throws JNCException {
        String path = "fqName[fqNameValue]";
        delete(path);
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "fq-name" leaf-list will not have a value.
     */
    public void addFqName() throws JNCException {
        setLeafListValue(Ifmap.NAMESPACE,
            "fq-name",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf-list "fq-name" with operation "replace".
     * @param fqNameValue The value to mark
     */
    public void markFqNameReplace(YangString fqNameValue) throws JNCException {
        markLeafReplace("fqName[name='" + fqNameValue + "']");
    }

    /**
     * Marks the leaf-list "fq-name" with operation "merge".
     * @param fqNameValue The value to mark
     */
    public void markFqNameMerge(YangString fqNameValue) throws JNCException {
        markLeafMerge("fqName[name='" + fqNameValue + "']");
    }

    /**
     * Marks the leaf-list "fq-name" with operation "create".
     * @param fqNameValue The value to mark
     */
    public void markFqNameCreate(YangString fqNameValue) throws JNCException {
        markLeafCreate("fqName[name='" + fqNameValue + "']");
    }

    /**
     * Marks the leaf-list "fq-name" with operation "delete".
     * @param fqNameValue The value to mark
     */
    public void markFqNameDelete(YangString fqNameValue) throws JNCException {
        markLeafDelete("fqName[name='" + fqNameValue + "']");
    }

    /* Access methods for leaf child: "uuid". */

    /**
     * Gets the value for child leaf "uuid".
     * @return The value of the leaf.
     */
    public Uuid getUuidValue() throws JNCException {
        return (Uuid)getValue("uuid");
    }

    /**
     * Sets the value for child leaf "uuid",
     * using a JNC type value.
     * @param uuidValue The value to set.
     * @param uuidValue used during instantiation.
     */
    public void setUuidValue(Uuid uuidValue) throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "uuid",
            uuidValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "uuid",
     * using a String value.
     * @param uuidValue used during instantiation.
     */
    public void setUuidValue(String uuidValue) throws JNCException {
        setUuidValue(new Uuid(uuidValue));
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "uuid" leaf will not have a value.
     */
    public void addUuid() throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "uuid",
            null,
            childrenNames());
    }

    /* Access methods for optional leaf child: "href". */

    /**
     * Gets the value for child leaf "href".
     * @return The value of the leaf.
     */
    public Uri getHrefValue() throws JNCException {
        return (Uri)getValue("href");
    }

    /**
     * Sets the value for child leaf "href",
     * using a JNC type value.
     * @param hrefValue The value to set.
     * @param hrefValue used during instantiation.
     */
    public void setHrefValue(Uri hrefValue) throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "href",
            hrefValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "href",
     * using a String value.
     * @param hrefValue used during instantiation.
     */
    public void setHrefValue(String hrefValue) throws JNCException {
        setHrefValue(new Uri(hrefValue));
    }

    /**
     * Unsets the value for child leaf "href".
     */
    public void unsetHrefValue() throws JNCException {
        delete("href");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "href" leaf will not have a value.
     */
    public void addHref() throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "href",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "href" with operation "replace".
     */
    public void markHrefReplace() throws JNCException {
        markLeafReplace("href");
    }

    /**
     * Marks the leaf "href" with operation "merge".
     */
    public void markHrefMerge() throws JNCException {
        markLeafMerge("href");
    }

    /**
     * Marks the leaf "href" with operation "create".
     */
    public void markHrefCreate() throws JNCException {
        markLeafCreate("href");
    }

    /**
     * Marks the leaf "href" with operation "delete".
     */
    public void markHrefDelete() throws JNCException {
        markLeafDelete("href");
    }

    /* Access methods for optional leaf child: "parent-uuid". */

    /**
     * Gets the value for child leaf "parent-uuid".
     * @return The value of the leaf.
     */
    public Uuid getParentUuidValue() throws JNCException {
        return (Uuid)getValue("parent-uuid");
    }

    /**
     * Sets the value for child leaf "parent-uuid",
     * using a JNC type value.
     * @param parentUuidValue The value to set.
     * @param parentUuidValue used during instantiation.
     */
    public void setParentUuidValue(Uuid parentUuidValue) throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "parent-uuid",
            parentUuidValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "parent-uuid",
     * using a String value.
     * @param parentUuidValue used during instantiation.
     */
    public void setParentUuidValue(String parentUuidValue) throws JNCException {
        setParentUuidValue(new Uuid(parentUuidValue));
    }

    /**
     * Unsets the value for child leaf "parent-uuid".
     */
    public void unsetParentUuidValue() throws JNCException {
        delete("parent-uuid");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "parent-uuid" leaf will not have a value.
     */
    public void addParentUuid() throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "parent-uuid",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "parent-uuid" with operation "replace".
     */
    public void markParentUuidReplace() throws JNCException {
        markLeafReplace("parentUuid");
    }

    /**
     * Marks the leaf "parent-uuid" with operation "merge".
     */
    public void markParentUuidMerge() throws JNCException {
        markLeafMerge("parentUuid");
    }

    /**
     * Marks the leaf "parent-uuid" with operation "create".
     */
    public void markParentUuidCreate() throws JNCException {
        markLeafCreate("parentUuid");
    }

    /**
     * Marks the leaf "parent-uuid" with operation "delete".
     */
    public void markParentUuidDelete() throws JNCException {
        markLeafDelete("parentUuid");
    }

    /* Access methods for optional leaf child: "parent-href". */

    /**
     * Gets the value for child leaf "parent-href".
     * @return The value of the leaf.
     */
    public Uri getParentHrefValue() throws JNCException {
        return (Uri)getValue("parent-href");
    }

    /**
     * Sets the value for child leaf "parent-href",
     * using a JNC type value.
     * @param parentHrefValue The value to set.
     * @param parentHrefValue used during instantiation.
     */
    public void setParentHrefValue(Uri parentHrefValue) throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "parent-href",
            parentHrefValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "parent-href",
     * using a String value.
     * @param parentHrefValue used during instantiation.
     */
    public void setParentHrefValue(String parentHrefValue) throws JNCException {
        setParentHrefValue(new Uri(parentHrefValue));
    }

    /**
     * Unsets the value for child leaf "parent-href".
     */
    public void unsetParentHrefValue() throws JNCException {
        delete("parent-href");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "parent-href" leaf will not have a value.
     */
    public void addParentHref() throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "parent-href",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "parent-href" with operation "replace".
     */
    public void markParentHrefReplace() throws JNCException {
        markLeafReplace("parentHref");
    }

    /**
     * Marks the leaf "parent-href" with operation "merge".
     */
    public void markParentHrefMerge() throws JNCException {
        markLeafMerge("parentHref");
    }

    /**
     * Marks the leaf "parent-href" with operation "create".
     */
    public void markParentHrefCreate() throws JNCException {
        markLeafCreate("parentHref");
    }

    /**
     * Marks the leaf "parent-href" with operation "delete".
     */
    public void markParentHrefDelete() throws JNCException {
        markLeafDelete("parentHref");
    }

    /* Access methods for optional leaf child: "parent-type". */

    /**
     * Gets the value for child leaf "parent-type".
     * @return The value of the leaf.
     */
    public YangString getParentTypeValue() throws JNCException {
        return (YangString)getValue("parent-type");
    }

    /**
     * Sets the value for child leaf "parent-type",
     * using instance of generated typedef class.
     * @param parentTypeValue The value to set.
     * @param parentTypeValue used during instantiation.
     */
    public void setParentTypeValue(YangString parentTypeValue)
            throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "parent-type",
            parentTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "parent-type",
     * using a String value.
     * @param parentTypeValue used during instantiation.
     */
    public void setParentTypeValue(String parentTypeValue) throws JNCException {
        setParentTypeValue(new YangString(parentTypeValue));
    }

    /**
     * Unsets the value for child leaf "parent-type".
     */
    public void unsetParentTypeValue() throws JNCException {
        delete("parent-type");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "parent-type" leaf will not have a value.
     */
    public void addParentType() throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "parent-type",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "parent-type" with operation "replace".
     */
    public void markParentTypeReplace() throws JNCException {
        markLeafReplace("parentType");
    }

    /**
     * Marks the leaf "parent-type" with operation "merge".
     */
    public void markParentTypeMerge() throws JNCException {
        markLeafMerge("parentType");
    }

    /**
     * Marks the leaf "parent-type" with operation "create".
     */
    public void markParentTypeCreate() throws JNCException {
        markLeafCreate("parentType");
    }

    /**
     * Marks the leaf "parent-type" with operation "delete".
     */
    public void markParentTypeDelete() throws JNCException {
        markLeafDelete("parentType");
    }

    /* Access methods for optional leaf child: "display-name". */

    /**
     * Gets the value for child leaf "display-name".
     * @return The value of the leaf.
     */
    public YangString getDisplayNameValue() throws JNCException {
        return (YangString)getValue("display-name");
    }

    /**
     * Sets the value for child leaf "display-name",
     * using instance of generated typedef class.
     * @param displayNameValue The value to set.
     * @param displayNameValue used during instantiation.
     */
    public void setDisplayNameValue(YangString displayNameValue)
            throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "display-name",
            displayNameValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "display-name",
     * using a String value.
     * @param displayNameValue used during instantiation.
     */
    public void setDisplayNameValue(String displayNameValue)
            throws JNCException {
        setDisplayNameValue(new YangString(displayNameValue));
    }

    /**
     * Unsets the value for child leaf "display-name".
     */
    public void unsetDisplayNameValue() throws JNCException {
        delete("display-name");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "display-name" leaf will not have a value.
     */
    public void addDisplayName() throws JNCException {
        setLeafValue(Ifmap.NAMESPACE,
            "display-name",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "display-name" with operation "replace".
     */
    public void markDisplayNameReplace() throws JNCException {
        markLeafReplace("displayName");
    }

    /**
     * Marks the leaf "display-name" with operation "merge".
     */
    public void markDisplayNameMerge() throws JNCException {
        markLeafMerge("displayName");
    }

    /**
     * Marks the leaf "display-name" with operation "create".
     */
    public void markDisplayNameCreate() throws JNCException {
        markLeafCreate("displayName");
    }

    /**
     * Marks the leaf "display-name" with operation "delete".
     */
    public void markDisplayNameDelete() throws JNCException {
        markLeafDelete("displayName");
    }

    /* Access methods for container child: "id-perms". */

    /**
     * Adds container entry "idPerms", using an existing object.
     * @param idPerms The object to add.
     * @return The added child.
     */
    public IdPerms addIdPerms(IdPerms idPerms) throws JNCException {
        this.idPerms = idPerms;
        insertChild(idPerms, childrenNames());
        return idPerms;
    }

    /**
     * Adds container entry "idPerms".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public IdPerms addIdPerms() throws JNCException {
        IdPerms idPerms = new IdPerms();
        this.idPerms = idPerms;
        insertChild(idPerms, childrenNames());
        return idPerms;
    }

    /**
     * Deletes container entry "idPerms".
     * @return An array of the deleted element nodes.
     */
    public NodeSet deleteIdPerms() throws JNCException {
        this.idPerms = null;
        String path = "id-perms";
        return delete(path);
    }

    /* Access methods for optional leaf child: "deviceType". */

    /**
     * Gets the value for child leaf "deviceType".
     * @return The value of the leaf.
     */
    public YangString getDeviceTypeValue() throws JNCException {
        return (YangString)getValue("deviceType");
    }

    /**
     * Sets the value for child leaf "deviceType",
     * using instance of generated typedef class.
     * @param deviceTypeValue The value to set.
     * @param deviceTypeValue used during instantiation.
     */
    public void setDeviceTypeValue(YangString deviceTypeValue)
            throws JNCException {
        setLeafValue(Devicemgt.NAMESPACE,
            "deviceType",
            deviceTypeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "deviceType",
     * using a String value.
     * @param deviceTypeValue used during instantiation.
     */
    public void setDeviceTypeValue(String deviceTypeValue) throws JNCException {
        setDeviceTypeValue(new YangString(deviceTypeValue));
    }

    /**
     * Unsets the value for child leaf "deviceType".
     */
    public void unsetDeviceTypeValue() throws JNCException {
        delete("deviceType");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "deviceType" leaf will not have a value.
     */
    public void addDeviceType() throws JNCException {
        setLeafValue(Devicemgt.NAMESPACE,
            "deviceType",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "deviceType" with operation "replace".
     */
    public void markDeviceTypeReplace() throws JNCException {
        markLeafReplace("deviceType");
    }

    /**
     * Marks the leaf "deviceType" with operation "merge".
     */
    public void markDeviceTypeMerge() throws JNCException {
        markLeafMerge("deviceType");
    }

    /**
     * Marks the leaf "deviceType" with operation "create".
     */
    public void markDeviceTypeCreate() throws JNCException {
        markLeafCreate("deviceType");
    }

    /**
     * Marks the leaf "deviceType" with operation "delete".
     */
    public void markDeviceTypeDelete() throws JNCException {
        markLeafDelete("deviceType");
    }

    /* Access methods for container child: "system". */

    /**
     * Adds container entry "system", using an existing object.
     * @param system The object to add.
     * @return The added child.
     */
    public System addSystem(System system) throws JNCException {
        this.system = system;
        insertChild(system, childrenNames());
        return system;
    }

    /**
     * Adds container entry "system".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public System addSystem() throws JNCException {
        System system = new System();
        this.system = system;
        insertChild(system, childrenNames());
        return system;
    }

    /**
     * Deletes container entry "system".
     * @return An array of the deleted element nodes.
     */
    public NodeSet deleteSystem() throws JNCException {
        this.system = null;
        String path = "system";
        return delete(path);
    }

    /* Access methods for container child: "lsysInfo". */

    /**
     * Adds container entry "lsysInfo", using an existing object.
     * @param lsysInfo The object to add.
     * @return The added child.
     */
    public LsysInfo addLsysInfo(LsysInfo lsysInfo) throws JNCException {
        this.lsysInfo = lsysInfo;
        insertChild(lsysInfo, childrenNames());
        return lsysInfo;
    }

    /**
     * Adds container entry "lsysInfo".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public LsysInfo addLsysInfo() throws JNCException {
        LsysInfo lsysInfo = new LsysInfo();
        this.lsysInfo = lsysInfo;
        insertChild(lsysInfo, childrenNames());
        return lsysInfo;
    }

    /**
     * Deletes container entry "lsysInfo".
     * @return An array of the deleted element nodes.
     */
    public NodeSet deleteLsysInfo() throws JNCException {
        this.lsysInfo = null;
        String path = "lsysInfo";
        return delete(path);
    }

    /* Access methods for container child: "redundancy". */

    /**
     * Adds container entry "redundancy", using an existing object.
     * @param redundancy The object to add.
     * @return The added child.
     */
    public Redundancy addRedundancy(Redundancy redundancy) throws JNCException {
        this.redundancy = redundancy;
        insertChild(redundancy, childrenNames());
        return redundancy;
    }

    /**
     * Adds container entry "redundancy".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public Redundancy addRedundancy() throws JNCException {
        Redundancy redundancy = new Redundancy();
        this.redundancy = redundancy;
        insertChild(redundancy, childrenNames());
        return redundancy;
    }

    /**
     * Deletes container entry "redundancy".
     * @return An array of the deleted element nodes.
     */
    public NodeSet deleteRedundancy() throws JNCException {
        this.redundancy = null;
        String path = "redundancy";
        return delete(path);
    }

    /* Access methods for container child: "configInfo". */

    /**
     * Adds container entry "configInfo", using an existing object.
     * @param configInfo The object to add.
     * @return The added child.
     */
    public ConfigInfo addConfigInfo(ConfigInfo configInfo) throws JNCException {
        this.configInfo = configInfo;
        insertChild(configInfo, childrenNames());
        return configInfo;
    }

    /**
     * Adds container entry "configInfo".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public ConfigInfo addConfigInfo() throws JNCException {
        ConfigInfo configInfo = new ConfigInfo();
        this.configInfo = configInfo;
        insertChild(configInfo, childrenNames());
        return configInfo;
    }

    /**
     * Deletes container entry "configInfo".
     * @return An array of the deleted element nodes.
     */
    public NodeSet deleteConfigInfo() throws JNCException {
        this.configInfo = null;
        String path = "configInfo";
        return delete(path);
    }

    /* Access methods for container child: "mgtConnection". */

    /**
     * Adds container entry "mgtConnection", using an existing object.
     * @param mgtConnection The object to add.
     * @return The added child.
     */
    public MgtConnection addMgtConnection(MgtConnection mgtConnection)
            throws JNCException {
        this.mgtConnection = mgtConnection;
        insertChild(mgtConnection, childrenNames());
        return mgtConnection;
    }

    /**
     * Adds container entry "mgtConnection".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public MgtConnection addMgtConnection() throws JNCException {
        MgtConnection mgtConnection = new MgtConnection();
        this.mgtConnection = mgtConnection;
        insertChild(mgtConnection, childrenNames());
        return mgtConnection;
    }

    /**
     * Deletes container entry "mgtConnection".
     * @return An array of the deleted element nodes.
     */
    public NodeSet deleteMgtConnection() throws JNCException {
        this.mgtConnection = null;
        String path = "mgtConnection";
        return delete(path);
    }

    /* Access methods for list child: "interface". */

    /**
     * Gets list entry "interface_", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public JInterface getJInterface(Uuid uuidValue) throws JNCException {
        String path = "interface[uuid='" + uuidValue + "']";
        return (JInterface)searchOne(path);
    }

    /**
     * Gets list entry "interface_", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public JInterface getJInterface(String uuidValue) throws JNCException {
        String path = "interface[uuid='" + uuidValue + "']";
        return (JInterface)searchOne(path);
    }

    /**
     * Iterator method for the list "interface".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator interface_Iterator() {
        return new ElementChildrenIterator(children, "interface");
    }

    /**
     * Adds list entry "interface_", using an existing object.
     * @param interface_ The object to add.
     * @return The added child.
     */
    public JInterface addJInterface(JInterface interface_) throws JNCException {
        insertChild(interface_, childrenNames());
        return interface_;
    }

    /**
     * Adds list entry "interface_", with specified keys.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public JInterface addJInterface(Uuid uuidValue) throws JNCException {
        JInterface interface_ = new JInterface(uuidValue);
        return addJInterface(interface_);
    }

    /**
     * Adds list entry "interface_", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public JInterface addJInterface(String uuidValue) throws JNCException {
        JInterface interface_ = new JInterface(uuidValue);
        return addJInterface(interface_);
    }

    /**
     * Adds list entry "interface_".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public JInterface addJInterface() throws JNCException {
        JInterface interface_ = new JInterface();
        insertChild(interface_, childrenNames());
        return interface_;
    }

    /**
     * Deletes list entry "interface_", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public void deleteJInterface(Uuid uuidValue) throws JNCException {
        String path = "interface[uuid='" + uuidValue + "']";
        delete(path);
    }

    /**
     * Deletes list entry "interface_", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public void deleteJInterface(String uuidValue) throws JNCException {
        String path = "interface[uuid='" + uuidValue + "']";
        delete(path);
    }

    /* Access methods for list child: "inventory". */

    /**
     * Gets list entry "inventory", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public Inventory getInventory(Uuid uuidValue) throws JNCException {
        String path = "inventory[uuid='" + uuidValue + "']";
        return (Inventory)searchOne(path);
    }

    /**
     * Gets list entry "inventory", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public Inventory getInventory(String uuidValue) throws JNCException {
        String path = "inventory[uuid='" + uuidValue + "']";
        return (Inventory)searchOne(path);
    }

    /**
     * Iterator method for the list "inventory".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator inventoryIterator() {
        return new ElementChildrenIterator(children, "inventory");
    }

    /**
     * Adds list entry "inventory", using an existing object.
     * @param inventory The object to add.
     * @return The added child.
     */
    public Inventory addInventory(Inventory inventory) throws JNCException {
        insertChild(inventory, childrenNames());
        return inventory;
    }

    /**
     * Adds list entry "inventory", with specified keys.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public Inventory addInventory(Uuid uuidValue) throws JNCException {
        Inventory inventory = new Inventory(uuidValue);
        return addInventory(inventory);
    }

    /**
     * Adds list entry "inventory", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public Inventory addInventory(String uuidValue) throws JNCException {
        Inventory inventory = new Inventory(uuidValue);
        return addInventory(inventory);
    }

    /**
     * Adds list entry "inventory".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public Inventory addInventory() throws JNCException {
        Inventory inventory = new Inventory();
        insertChild(inventory, childrenNames());
        return inventory;
    }

    /**
     * Deletes list entry "inventory", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public void deleteInventory(Uuid uuidValue) throws JNCException {
        String path = "inventory[uuid='" + uuidValue + "']";
        delete(path);
    }

    /**
     * Deletes list entry "inventory", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public void deleteInventory(String uuidValue) throws JNCException {
        String path = "inventory[uuid='" + uuidValue + "']";
        delete(path);
    }

    /* Access methods for list child: "activeConfigurations". */

    /**
     * Gets list entry "activeConfigurations", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public ActiveConfigurations getActiveConfigurations(Uuid uuidValue)
            throws JNCException {
        String path = "activeConfigurations[uuid='" + uuidValue + "']";
        return (ActiveConfigurations)searchOne(path);
    }

    /**
     * Gets list entry "activeConfigurations", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public ActiveConfigurations getActiveConfigurations(String uuidValue)
            throws JNCException {
        String path = "activeConfigurations[uuid='" + uuidValue + "']";
        return (ActiveConfigurations)searchOne(path);
    }

    /**
     * Iterator method for the list "activeConfigurations".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator activeConfigurationsIterator() {
        return new ElementChildrenIterator(children, "activeConfigurations");
    }

    /**
     * Adds list entry "activeConfigurations", using an existing object.
     * @param activeConfigurations The object to add.
     * @return The added child.
     */
    public ActiveConfigurations addActiveConfigurations(ActiveConfigurations activeConfigurations)
            throws JNCException {
        insertChild(activeConfigurations, childrenNames());
        return activeConfigurations;
    }

    /**
     * Adds list entry "activeConfigurations", with specified keys.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public ActiveConfigurations addActiveConfigurations(Uuid uuidValue)
            throws JNCException {
        ActiveConfigurations activeConfigurations = new ActiveConfigurations(uuidValue);
        return addActiveConfigurations(activeConfigurations);
    }

    /**
     * Adds list entry "activeConfigurations", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public ActiveConfigurations addActiveConfigurations(String uuidValue)
            throws JNCException {
        ActiveConfigurations activeConfigurations = new ActiveConfigurations(uuidValue);
        return addActiveConfigurations(activeConfigurations);
    }

    /**
     * Adds list entry "activeConfigurations".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public ActiveConfigurations addActiveConfigurations() throws JNCException {
        ActiveConfigurations activeConfigurations = new ActiveConfigurations();
        insertChild(activeConfigurations, childrenNames());
        return activeConfigurations;
    }

    /**
     * Deletes list entry "activeConfigurations", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public void deleteActiveConfigurations(Uuid uuidValue) throws JNCException {
        String path = "activeConfigurations[uuid='" + uuidValue + "']";
        delete(path);
    }

    /**
     * Deletes list entry "activeConfigurations", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public void deleteActiveConfigurations(String uuidValue)
            throws JNCException {
        String path = "activeConfigurations[uuid='" + uuidValue + "']";
        delete(path);
    }

    /* Access methods for list child: "templates". */

    /**
     * Gets list entry "templates", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public Templates getTemplates(Uuid uuidValue) throws JNCException {
        String path = "templates[uuid='" + uuidValue + "']";
        return (Templates)searchOne(path);
    }

    /**
     * Gets list entry "templates", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public Templates getTemplates(String uuidValue) throws JNCException {
        String path = "templates[uuid='" + uuidValue + "']";
        return (Templates)searchOne(path);
    }

    /**
     * Iterator method for the list "templates".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator templatesIterator() {
        return new ElementChildrenIterator(children, "templates");
    }

    /**
     * Adds list entry "templates", using an existing object.
     * @param templates The object to add.
     * @return The added child.
     */
    public Templates addTemplates(Templates templates) throws JNCException {
        insertChild(templates, childrenNames());
        return templates;
    }

    /**
     * Adds list entry "templates", with specified keys.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public Templates addTemplates(Uuid uuidValue) throws JNCException {
        Templates templates = new Templates(uuidValue);
        return addTemplates(templates);
    }

    /**
     * Adds list entry "templates", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public Templates addTemplates(String uuidValue) throws JNCException {
        Templates templates = new Templates(uuidValue);
        return addTemplates(templates);
    }

    /**
     * Adds list entry "templates".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public Templates addTemplates() throws JNCException {
        Templates templates = new Templates();
        insertChild(templates, childrenNames());
        return templates;
    }

    /**
     * Deletes list entry "templates", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public void deleteTemplates(Uuid uuidValue) throws JNCException {
        String path = "templates[uuid='" + uuidValue + "']";
        delete(path);
    }

    /**
     * Deletes list entry "templates", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public void deleteTemplates(String uuidValue) throws JNCException {
        String path = "templates[uuid='" + uuidValue + "']";
        delete(path);
    }

    /* Access methods for list child: "oobChanges". */

    /**
     * Gets list entry "oobChanges", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public OobChanges getOobChanges(Uuid uuidValue) throws JNCException {
        String path = "oobChanges[uuid='" + uuidValue + "']";
        return (OobChanges)searchOne(path);
    }

    /**
     * Gets list entry "oobChanges", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public OobChanges getOobChanges(String uuidValue) throws JNCException {
        String path = "oobChanges[uuid='" + uuidValue + "']";
        return (OobChanges)searchOne(path);
    }

    /**
     * Iterator method for the list "oobChanges".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator oobChangesIterator() {
        return new ElementChildrenIterator(children, "oobChanges");
    }

    /**
     * Adds list entry "oobChanges", using an existing object.
     * @param oobChanges The object to add.
     * @return The added child.
     */
    public OobChanges addOobChanges(OobChanges oobChanges) throws JNCException {
        insertChild(oobChanges, childrenNames());
        return oobChanges;
    }

    /**
     * Adds list entry "oobChanges", with specified keys.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public OobChanges addOobChanges(Uuid uuidValue) throws JNCException {
        OobChanges oobChanges = new OobChanges(uuidValue);
        return addOobChanges(oobChanges);
    }

    /**
     * Adds list entry "oobChanges", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public OobChanges addOobChanges(String uuidValue) throws JNCException {
        OobChanges oobChanges = new OobChanges(uuidValue);
        return addOobChanges(oobChanges);
    }

    /**
     * Adds list entry "oobChanges".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public OobChanges addOobChanges() throws JNCException {
        OobChanges oobChanges = new OobChanges();
        insertChild(oobChanges, childrenNames());
        return oobChanges;
    }

    /**
     * Deletes list entry "oobChanges", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public void deleteOobChanges(Uuid uuidValue) throws JNCException {
        String path = "oobChanges[uuid='" + uuidValue + "']";
        delete(path);
    }

    /**
     * Deletes list entry "oobChanges", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public void deleteOobChanges(String uuidValue) throws JNCException {
        String path = "oobChanges[uuid='" + uuidValue + "']";
        delete(path);
    }

    /* Access methods for list child: "changeLogs". */

    /**
     * Gets list entry "changeLogs", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public ChangeLogs getChangeLogs(Uuid uuidValue) throws JNCException {
        String path = "changeLogs[uuid='" + uuidValue + "']";
        return (ChangeLogs)searchOne(path);
    }

    /**
     * Gets list entry "changeLogs", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public ChangeLogs getChangeLogs(String uuidValue) throws JNCException {
        String path = "changeLogs[uuid='" + uuidValue + "']";
        return (ChangeLogs)searchOne(path);
    }

    /**
     * Iterator method for the list "changeLogs".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator changeLogsIterator() {
        return new ElementChildrenIterator(children, "changeLogs");
    }

    /**
     * Adds list entry "changeLogs", using an existing object.
     * @param changeLogs The object to add.
     * @return The added child.
     */
    public ChangeLogs addChangeLogs(ChangeLogs changeLogs) throws JNCException {
        insertChild(changeLogs, childrenNames());
        return changeLogs;
    }

    /**
     * Adds list entry "changeLogs", with specified keys.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public ChangeLogs addChangeLogs(Uuid uuidValue) throws JNCException {
        ChangeLogs changeLogs = new ChangeLogs(uuidValue);
        return addChangeLogs(changeLogs);
    }

    /**
     * Adds list entry "changeLogs", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public ChangeLogs addChangeLogs(String uuidValue) throws JNCException {
        ChangeLogs changeLogs = new ChangeLogs(uuidValue);
        return addChangeLogs(changeLogs);
    }

    /**
     * Adds list entry "changeLogs".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public ChangeLogs addChangeLogs() throws JNCException {
        ChangeLogs changeLogs = new ChangeLogs();
        insertChild(changeLogs, childrenNames());
        return changeLogs;
    }

    /**
     * Deletes list entry "changeLogs", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public void deleteChangeLogs(Uuid uuidValue) throws JNCException {
        String path = "changeLogs[uuid='" + uuidValue + "']";
        delete(path);
    }

    /**
     * Deletes list entry "changeLogs", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public void deleteChangeLogs(String uuidValue) throws JNCException {
        String path = "changeLogs[uuid='" + uuidValue + "']";
        delete(path);
    }

    /* Access methods for list child: "associatedScripts". */

    /**
     * Gets list entry "associatedScripts", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public AssociatedScripts getAssociatedScripts(Uuid uuidValue)
            throws JNCException {
        String path = "associatedScripts[uuid='" + uuidValue + "']";
        return (AssociatedScripts)searchOne(path);
    }

    /**
     * Gets list entry "associatedScripts", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public AssociatedScripts getAssociatedScripts(String uuidValue)
            throws JNCException {
        String path = "associatedScripts[uuid='" + uuidValue + "']";
        return (AssociatedScripts)searchOne(path);
    }

    /**
     * Iterator method for the list "associatedScripts".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator associatedScriptsIterator() {
        return new ElementChildrenIterator(children, "associatedScripts");
    }

    /**
     * Adds list entry "associatedScripts", using an existing object.
     * @param associatedScripts The object to add.
     * @return The added child.
     */
    public AssociatedScripts addAssociatedScripts(AssociatedScripts associatedScripts)
            throws JNCException {
        insertChild(associatedScripts, childrenNames());
        return associatedScripts;
    }

    /**
     * Adds list entry "associatedScripts", with specified keys.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public AssociatedScripts addAssociatedScripts(Uuid uuidValue)
            throws JNCException {
        AssociatedScripts associatedScripts = new AssociatedScripts(uuidValue);
        return addAssociatedScripts(associatedScripts);
    }

    /**
     * Adds list entry "associatedScripts", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public AssociatedScripts addAssociatedScripts(String uuidValue)
            throws JNCException {
        AssociatedScripts associatedScripts = new AssociatedScripts(uuidValue);
        return addAssociatedScripts(associatedScripts);
    }

    /**
     * Adds list entry "associatedScripts".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public AssociatedScripts addAssociatedScripts() throws JNCException {
        AssociatedScripts associatedScripts = new AssociatedScripts();
        insertChild(associatedScripts, childrenNames());
        return associatedScripts;
    }

    /**
     * Deletes list entry "associatedScripts", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public void deleteAssociatedScripts(Uuid uuidValue) throws JNCException {
        String path = "associatedScripts[uuid='" + uuidValue + "']";
        delete(path);
    }

    /**
     * Deletes list entry "associatedScripts", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public void deleteAssociatedScripts(String uuidValue) throws JNCException {
        String path = "associatedScripts[uuid='" + uuidValue + "']";
        delete(path);
    }

    /* Access methods for list child: "scriptExecutionHistories". */

    /**
     * Gets list entry "scriptExecutionHistories", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public ScriptExecutionHistories getScriptExecutionHistories(Uuid uuidValue)
            throws JNCException {
        String path = "scriptExecutionHistories[uuid='" + uuidValue + "']";
        return (ScriptExecutionHistories)searchOne(path);
    }

    /**
     * Gets list entry "scriptExecutionHistories", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public ScriptExecutionHistories getScriptExecutionHistories(String uuidValue)
            throws JNCException {
        String path = "scriptExecutionHistories[uuid='" + uuidValue + "']";
        return (ScriptExecutionHistories)searchOne(path);
    }

    /**
     * Iterator method for the list "scriptExecutionHistories".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator scriptExecutionHistoriesIterator() {
        return new ElementChildrenIterator(children, "scriptExecutionHistories");
    }

    /**
     * Adds list entry "scriptExecutionHistories", using an existing object.
     * @param scriptExecutionHistories The object to add.
     * @return The added child.
     */
    public ScriptExecutionHistories addScriptExecutionHistories(ScriptExecutionHistories scriptExecutionHistories)
            throws JNCException {
        insertChild(scriptExecutionHistories, childrenNames());
        return scriptExecutionHistories;
    }

    /**
     * Adds list entry "scriptExecutionHistories", with specified keys.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public ScriptExecutionHistories addScriptExecutionHistories(Uuid uuidValue)
            throws JNCException {
        ScriptExecutionHistories scriptExecutionHistories = new ScriptExecutionHistories(uuidValue);
        return addScriptExecutionHistories(scriptExecutionHistories);
    }

    /**
     * Adds list entry "scriptExecutionHistories", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public ScriptExecutionHistories addScriptExecutionHistories(String uuidValue)
            throws JNCException {
        ScriptExecutionHistories scriptExecutionHistories = new ScriptExecutionHistories(uuidValue);
        return addScriptExecutionHistories(scriptExecutionHistories);
    }

    /**
     * Adds list entry "scriptExecutionHistories".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public ScriptExecutionHistories addScriptExecutionHistories()
            throws JNCException {
        ScriptExecutionHistories scriptExecutionHistories = new ScriptExecutionHistories();
        insertChild(scriptExecutionHistories, childrenNames());
        return scriptExecutionHistories;
    }

    /**
     * Deletes list entry "scriptExecutionHistories", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public void deleteScriptExecutionHistories(Uuid uuidValue)
            throws JNCException {
        String path = "scriptExecutionHistories[uuid='" + uuidValue + "']";
        delete(path);
    }

    /**
     * Deletes list entry "scriptExecutionHistories", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public void deleteScriptExecutionHistories(String uuidValue)
            throws JNCException {
        String path = "scriptExecutionHistories[uuid='" + uuidValue + "']";
        delete(path);
    }

    /* Access methods for list child: "partitions". */

    /**
     * Gets list entry "partitions", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public Partitions getPartitions(Uuid uuidValue) throws JNCException {
        String path = "partitions[uuid='" + uuidValue + "']";
        return (Partitions)searchOne(path);
    }

    /**
     * Gets list entry "partitions", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public Partitions getPartitions(String uuidValue) throws JNCException {
        String path = "partitions[uuid='" + uuidValue + "']";
        return (Partitions)searchOne(path);
    }

    /**
     * Iterator method for the list "partitions".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator partitionsIterator() {
        return new ElementChildrenIterator(children, "partitions");
    }

    /**
     * Adds list entry "partitions", using an existing object.
     * @param partitions The object to add.
     * @return The added child.
     */
    public Partitions addPartitions(Partitions partitions) throws JNCException {
        insertChild(partitions, childrenNames());
        return partitions;
    }

    /**
     * Adds list entry "partitions", with specified keys.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public Partitions addPartitions(Uuid uuidValue) throws JNCException {
        Partitions partitions = new Partitions(uuidValue);
        return addPartitions(partitions);
    }

    /**
     * Adds list entry "partitions", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public Partitions addPartitions(String uuidValue) throws JNCException {
        Partitions partitions = new Partitions(uuidValue);
        return addPartitions(partitions);
    }

    /**
     * Adds list entry "partitions".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public Partitions addPartitions() throws JNCException {
        Partitions partitions = new Partitions();
        insertChild(partitions, childrenNames());
        return partitions;
    }

    /**
     * Deletes list entry "partitions", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public void deletePartitions(Uuid uuidValue) throws JNCException {
        String path = "partitions[uuid='" + uuidValue + "']";
        delete(path);
    }

    /**
     * Deletes list entry "partitions", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public void deletePartitions(String uuidValue) throws JNCException {
        String path = "partitions[uuid='" + uuidValue + "']";
        delete(path);
    }

    /* Access methods for list child: "stagedImages". */

    /**
     * Gets list entry "stagedImages", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public StagedImages getStagedImages(Uuid uuidValue) throws JNCException {
        String path = "stagedImages[uuid='" + uuidValue + "']";
        return (StagedImages)searchOne(path);
    }

    /**
     * Gets list entry "stagedImages", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public StagedImages getStagedImages(String uuidValue) throws JNCException {
        String path = "stagedImages[uuid='" + uuidValue + "']";
        return (StagedImages)searchOne(path);
    }

    /**
     * Iterator method for the list "stagedImages".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator stagedImagesIterator() {
        return new ElementChildrenIterator(children, "stagedImages");
    }

    /**
     * Adds list entry "stagedImages", using an existing object.
     * @param stagedImages The object to add.
     * @return The added child.
     */
    public StagedImages addStagedImages(StagedImages stagedImages)
            throws JNCException {
        insertChild(stagedImages, childrenNames());
        return stagedImages;
    }

    /**
     * Adds list entry "stagedImages", with specified keys.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public StagedImages addStagedImages(Uuid uuidValue) throws JNCException {
        StagedImages stagedImages = new StagedImages(uuidValue);
        return addStagedImages(stagedImages);
    }

    /**
     * Adds list entry "stagedImages", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public StagedImages addStagedImages(String uuidValue) throws JNCException {
        StagedImages stagedImages = new StagedImages(uuidValue);
        return addStagedImages(stagedImages);
    }

    /**
     * Adds list entry "stagedImages".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public StagedImages addStagedImages() throws JNCException {
        StagedImages stagedImages = new StagedImages();
        insertChild(stagedImages, childrenNames());
        return stagedImages;
    }

    /**
     * Deletes list entry "stagedImages", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public void deleteStagedImages(Uuid uuidValue) throws JNCException {
        String path = "stagedImages[uuid='" + uuidValue + "']";
        delete(path);
    }

    /**
     * Deletes list entry "stagedImages", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public void deleteStagedImages(String uuidValue) throws JNCException {
        String path = "stagedImages[uuid='" + uuidValue + "']";
        delete(path);
    }

    /* Access methods for list child: "softwares". */

    /**
     * Gets list entry "softwares", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public Softwares getSoftwares(Uuid uuidValue) throws JNCException {
        String path = "softwares[uuid='" + uuidValue + "']";
        return (Softwares)searchOne(path);
    }

    /**
     * Gets list entry "softwares", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public Softwares getSoftwares(String uuidValue) throws JNCException {
        String path = "softwares[uuid='" + uuidValue + "']";
        return (Softwares)searchOne(path);
    }

    /**
     * Iterator method for the list "softwares".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator softwaresIterator() {
        return new ElementChildrenIterator(children, "softwares");
    }

    /**
     * Adds list entry "softwares", using an existing object.
     * @param softwares The object to add.
     * @return The added child.
     */
    public Softwares addSoftwares(Softwares softwares) throws JNCException {
        insertChild(softwares, childrenNames());
        return softwares;
    }

    /**
     * Adds list entry "softwares", with specified keys.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public Softwares addSoftwares(Uuid uuidValue) throws JNCException {
        Softwares softwares = new Softwares(uuidValue);
        return addSoftwares(softwares);
    }

    /**
     * Adds list entry "softwares", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public Softwares addSoftwares(String uuidValue) throws JNCException {
        Softwares softwares = new Softwares(uuidValue);
        return addSoftwares(softwares);
    }

    /**
     * Adds list entry "softwares".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public Softwares addSoftwares() throws JNCException {
        Softwares softwares = new Softwares();
        insertChild(softwares, childrenNames());
        return softwares;
    }

    /**
     * Deletes list entry "softwares", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public void deleteSoftwares(Uuid uuidValue) throws JNCException {
        String path = "softwares[uuid='" + uuidValue + "']";
        delete(path);
    }

    /**
     * Deletes list entry "softwares", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public void deleteSoftwares(String uuidValue) throws JNCException {
        String path = "softwares[uuid='" + uuidValue + "']";
        delete(path);
    }

    /* Access methods for list child: "licenseUsageSummary". */

    /**
     * Gets list entry "licenseUsageSummary", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public LicenseUsageSummary getLicenseUsageSummary(Uuid uuidValue)
            throws JNCException {
        String path = "licenseUsageSummary[uuid='" + uuidValue + "']";
        return (LicenseUsageSummary)searchOne(path);
    }

    /**
     * Gets list entry "licenseUsageSummary", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public LicenseUsageSummary getLicenseUsageSummary(String uuidValue)
            throws JNCException {
        String path = "licenseUsageSummary[uuid='" + uuidValue + "']";
        return (LicenseUsageSummary)searchOne(path);
    }

    /**
     * Iterator method for the list "licenseUsageSummary".
     * @return An iterator for the list.
     */
    public ElementChildrenIterator licenseUsageSummaryIterator() {
        return new ElementChildrenIterator(children, "licenseUsageSummary");
    }

    /**
     * Adds list entry "licenseUsageSummary", using an existing object.
     * @param licenseUsageSummary The object to add.
     * @return The added child.
     */
    public LicenseUsageSummary addLicenseUsageSummary(LicenseUsageSummary licenseUsageSummary)
            throws JNCException {
        insertChild(licenseUsageSummary, childrenNames());
        return licenseUsageSummary;
    }

    /**
     * Adds list entry "licenseUsageSummary", with specified keys.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public LicenseUsageSummary addLicenseUsageSummary(Uuid uuidValue)
            throws JNCException {
        LicenseUsageSummary licenseUsageSummary = new LicenseUsageSummary(uuidValue);
        return addLicenseUsageSummary(licenseUsageSummary);
    }

    /**
     * Adds list entry "licenseUsageSummary", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     * @return The added child.
     */
    public LicenseUsageSummary addLicenseUsageSummary(String uuidValue)
            throws JNCException {
        LicenseUsageSummary licenseUsageSummary = new LicenseUsageSummary(uuidValue);
        return addLicenseUsageSummary(licenseUsageSummary);
    }

    /**
     * Adds list entry "licenseUsageSummary".
     * This method is used for creating subtree filters.
     * @return The added child.
     */
    public LicenseUsageSummary addLicenseUsageSummary() throws JNCException {
        LicenseUsageSummary licenseUsageSummary = new LicenseUsageSummary();
        insertChild(licenseUsageSummary, childrenNames());
        return licenseUsageSummary;
    }

    /**
     * Deletes list entry "licenseUsageSummary", with specified keys.
     * @param uuidValue Key argument of child.
     */
    public void deleteLicenseUsageSummary(Uuid uuidValue) throws JNCException {
        String path = "licenseUsageSummary[uuid='" + uuidValue + "']";
        delete(path);
    }

    /**
     * Deletes list entry "licenseUsageSummary", with specified keys.
     * The keys are specified as strings.
     * @param uuidValue Key argument of child.
     */
    public void deleteLicenseUsageSummary(String uuidValue) throws JNCException {
        String path = "licenseUsageSummary[uuid='" + uuidValue + "']";
        delete(path);
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
        if (child instanceof IdPerms) idPerms = (IdPerms)child;
        else if (child instanceof System) system = (System)child;
        else if (child instanceof LsysInfo) lsysInfo = (LsysInfo)child;
        else if (child instanceof Redundancy) redundancy = (Redundancy)child;
        else if (child instanceof ConfigInfo) configInfo = (ConfigInfo)child;
        else if (child instanceof MgtConnection) mgtConnection = (MgtConnection)child;
    }

}
