/* 
 * @(#)System.java        1.0 30/12/14
 *
 * This file has been auto-generated by JNC, the
 * Java output format plug-in of pyang.
 * Origin: module "devmgt", revision: "2014-09-16".
 */

package net.juniper.jspace.ems.yang.devmgt.devicemgt.devices.device;

import com.tailf.jnc.Element;
import com.tailf.jnc.JNCException;
import com.tailf.jnc.Tagpath;
import com.tailf.jnc.YangElement;
import com.tailf.jnc.YangString;
import com.tailf.jnc.YangUInt32;

import net.juniper.jspace.ems.yang.devmgt.Devmgt;

/**
 * This class represents an element from 
 * the namespace http://juniper.net/ns/space/test/1.0
 * generated to "src/net/juniper/jspace/ems/yang/devmgt/devicemgt/devices/device/system"
 * <p>
 * See line 29 in
 * /home/maxin/workspace/js-easy-rest/easy-rest-core/yang/devmgt.yang
 *
 * @version 1.0 2014-12-30
 * @author Auto Generated
 */
public class System extends YangElement {

    private static final long serialVersionUID = 1L;

    public static final Tagpath tagpath = new Tagpath("devmgt/devicemgt/devices/device/system");

    static {
        Devmgt.enable();
    }

    /**
     * Constructor for an empty System object.
     */
    public System() {
        super(Devmgt.NAMESPACE, "system");
    }

    /**
     * Clones this object, returning an exact copy.
     * @return A clone of the object.
     */
    public System clone() {
        return (System)cloneContent(new System());
    }

    /**
     * Clones this object, returning a shallow copy.
     * @return A clone of the object. Children are not included.
     */
    public System cloneShallow() {
        return (System)cloneShallowContent(new System());
    }

    /**
     * @return An array with the identifiers of any key children
     */
    public String[] keyNames() {
        return null;
    }

    /**
     * @return An array with the identifiers of any children, in order.
     */
    public String[] childrenNames() {
        return new String[] {
            "hostname",
            "ip",
            "vendor",
            "platform",
            "family",
            "osVersion",
            "serial",
            "lastRebootTime",
        };
    }

    /* Access methods for optional leaf child: "hostname". */

    /**
     * Gets the value for child leaf "hostname".
     * @return The value of the leaf.
     */
    public YangString getHostnameValue() throws JNCException {
        return (YangString)getValue("hostname");
    }

    /**
     * Sets the value for child leaf "hostname",
     * using instance of generated typedef class.
     * @param hostnameValue The value to set.
     * @param hostnameValue used during instantiation.
     */
    public void setHostnameValue(YangString hostnameValue) throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "hostname",
            hostnameValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "hostname",
     * using a String value.
     * @param hostnameValue used during instantiation.
     */
    public void setHostnameValue(String hostnameValue) throws JNCException {
        setHostnameValue(new YangString(hostnameValue));
    }

    /**
     * Unsets the value for child leaf "hostname".
     */
    public void unsetHostnameValue() throws JNCException {
        delete("hostname");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "hostname" leaf will not have a value.
     */
    public void addHostname() throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "hostname",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "hostname" with operation "replace".
     */
    public void markHostnameReplace() throws JNCException {
        markLeafReplace("hostname");
    }

    /**
     * Marks the leaf "hostname" with operation "merge".
     */
    public void markHostnameMerge() throws JNCException {
        markLeafMerge("hostname");
    }

    /**
     * Marks the leaf "hostname" with operation "create".
     */
    public void markHostnameCreate() throws JNCException {
        markLeafCreate("hostname");
    }

    /**
     * Marks the leaf "hostname" with operation "delete".
     */
    public void markHostnameDelete() throws JNCException {
        markLeafDelete("hostname");
    }

    /* Access methods for optional leaf child: "ip". */

    /**
     * Gets the value for child leaf "ip".
     * @return The value of the leaf.
     */
    public YangString getIpValue() throws JNCException {
        return (YangString)getValue("ip");
    }

    /**
     * Sets the value for child leaf "ip",
     * using instance of generated typedef class.
     * @param ipValue The value to set.
     * @param ipValue used during instantiation.
     */
    public void setIpValue(YangString ipValue) throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "ip",
            ipValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "ip",
     * using a String value.
     * @param ipValue used during instantiation.
     */
    public void setIpValue(String ipValue) throws JNCException {
        setIpValue(new YangString(ipValue));
    }

    /**
     * Unsets the value for child leaf "ip".
     */
    public void unsetIpValue() throws JNCException {
        delete("ip");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "ip" leaf will not have a value.
     */
    public void addIp() throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "ip",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "ip" with operation "replace".
     */
    public void markIpReplace() throws JNCException {
        markLeafReplace("ip");
    }

    /**
     * Marks the leaf "ip" with operation "merge".
     */
    public void markIpMerge() throws JNCException {
        markLeafMerge("ip");
    }

    /**
     * Marks the leaf "ip" with operation "create".
     */
    public void markIpCreate() throws JNCException {
        markLeafCreate("ip");
    }

    /**
     * Marks the leaf "ip" with operation "delete".
     */
    public void markIpDelete() throws JNCException {
        markLeafDelete("ip");
    }

    /* Access methods for optional leaf child: "vendor". */

    /**
     * Gets the value for child leaf "vendor".
     * @return The value of the leaf.
     */
    public YangString getVendorValue() throws JNCException {
        return (YangString)getValue("vendor");
    }

    /**
     * Sets the value for child leaf "vendor",
     * using instance of generated typedef class.
     * @param vendorValue The value to set.
     * @param vendorValue used during instantiation.
     */
    public void setVendorValue(YangString vendorValue) throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "vendor",
            vendorValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "vendor",
     * using a String value.
     * @param vendorValue used during instantiation.
     */
    public void setVendorValue(String vendorValue) throws JNCException {
        setVendorValue(new YangString(vendorValue));
    }

    /**
     * Unsets the value for child leaf "vendor".
     */
    public void unsetVendorValue() throws JNCException {
        delete("vendor");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "vendor" leaf will not have a value.
     */
    public void addVendor() throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "vendor",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "vendor" with operation "replace".
     */
    public void markVendorReplace() throws JNCException {
        markLeafReplace("vendor");
    }

    /**
     * Marks the leaf "vendor" with operation "merge".
     */
    public void markVendorMerge() throws JNCException {
        markLeafMerge("vendor");
    }

    /**
     * Marks the leaf "vendor" with operation "create".
     */
    public void markVendorCreate() throws JNCException {
        markLeafCreate("vendor");
    }

    /**
     * Marks the leaf "vendor" with operation "delete".
     */
    public void markVendorDelete() throws JNCException {
        markLeafDelete("vendor");
    }

    /* Access methods for optional leaf child: "platform". */

    /**
     * Gets the value for child leaf "platform".
     * @return The value of the leaf.
     */
    public YangString getPlatformValue() throws JNCException {
        return (YangString)getValue("platform");
    }

    /**
     * Sets the value for child leaf "platform",
     * using instance of generated typedef class.
     * @param platformValue The value to set.
     * @param platformValue used during instantiation.
     */
    public void setPlatformValue(YangString platformValue) throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "platform",
            platformValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "platform",
     * using a String value.
     * @param platformValue used during instantiation.
     */
    public void setPlatformValue(String platformValue) throws JNCException {
        setPlatformValue(new YangString(platformValue));
    }

    /**
     * Unsets the value for child leaf "platform".
     */
    public void unsetPlatformValue() throws JNCException {
        delete("platform");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "platform" leaf will not have a value.
     */
    public void addPlatform() throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "platform",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "platform" with operation "replace".
     */
    public void markPlatformReplace() throws JNCException {
        markLeafReplace("platform");
    }

    /**
     * Marks the leaf "platform" with operation "merge".
     */
    public void markPlatformMerge() throws JNCException {
        markLeafMerge("platform");
    }

    /**
     * Marks the leaf "platform" with operation "create".
     */
    public void markPlatformCreate() throws JNCException {
        markLeafCreate("platform");
    }

    /**
     * Marks the leaf "platform" with operation "delete".
     */
    public void markPlatformDelete() throws JNCException {
        markLeafDelete("platform");
    }

    /* Access methods for optional leaf child: "family". */

    /**
     * Gets the value for child leaf "family".
     * @return The value of the leaf.
     */
    public YangString getFamilyValue() throws JNCException {
        return (YangString)getValue("family");
    }

    /**
     * Sets the value for child leaf "family",
     * using instance of generated typedef class.
     * @param familyValue The value to set.
     * @param familyValue used during instantiation.
     */
    public void setFamilyValue(YangString familyValue) throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "family",
            familyValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "family",
     * using a String value.
     * @param familyValue used during instantiation.
     */
    public void setFamilyValue(String familyValue) throws JNCException {
        setFamilyValue(new YangString(familyValue));
    }

    /**
     * Unsets the value for child leaf "family".
     */
    public void unsetFamilyValue() throws JNCException {
        delete("family");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "family" leaf will not have a value.
     */
    public void addFamily() throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "family",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "family" with operation "replace".
     */
    public void markFamilyReplace() throws JNCException {
        markLeafReplace("family");
    }

    /**
     * Marks the leaf "family" with operation "merge".
     */
    public void markFamilyMerge() throws JNCException {
        markLeafMerge("family");
    }

    /**
     * Marks the leaf "family" with operation "create".
     */
    public void markFamilyCreate() throws JNCException {
        markLeafCreate("family");
    }

    /**
     * Marks the leaf "family" with operation "delete".
     */
    public void markFamilyDelete() throws JNCException {
        markLeafDelete("family");
    }

    /* Access methods for optional leaf child: "osVersion". */

    /**
     * Gets the value for child leaf "osVersion".
     * @return The value of the leaf.
     */
    public YangString getOsVersionValue() throws JNCException {
        return (YangString)getValue("osVersion");
    }

    /**
     * Sets the value for child leaf "osVersion",
     * using instance of generated typedef class.
     * @param osVersionValue The value to set.
     * @param osVersionValue used during instantiation.
     */
    public void setOsVersionValue(YangString osVersionValue)
            throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "osVersion",
            osVersionValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "osVersion",
     * using a String value.
     * @param osVersionValue used during instantiation.
     */
    public void setOsVersionValue(String osVersionValue) throws JNCException {
        setOsVersionValue(new YangString(osVersionValue));
    }

    /**
     * Unsets the value for child leaf "osVersion".
     */
    public void unsetOsVersionValue() throws JNCException {
        delete("osVersion");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "osVersion" leaf will not have a value.
     */
    public void addOsVersion() throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "osVersion",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "osVersion" with operation "replace".
     */
    public void markOsVersionReplace() throws JNCException {
        markLeafReplace("osVersion");
    }

    /**
     * Marks the leaf "osVersion" with operation "merge".
     */
    public void markOsVersionMerge() throws JNCException {
        markLeafMerge("osVersion");
    }

    /**
     * Marks the leaf "osVersion" with operation "create".
     */
    public void markOsVersionCreate() throws JNCException {
        markLeafCreate("osVersion");
    }

    /**
     * Marks the leaf "osVersion" with operation "delete".
     */
    public void markOsVersionDelete() throws JNCException {
        markLeafDelete("osVersion");
    }

    /* Access methods for optional leaf child: "serial". */

    /**
     * Gets the value for child leaf "serial".
     * @return The value of the leaf.
     */
    public YangString getSerialValue() throws JNCException {
        return (YangString)getValue("serial");
    }

    /**
     * Sets the value for child leaf "serial",
     * using instance of generated typedef class.
     * @param serialValue The value to set.
     * @param serialValue used during instantiation.
     */
    public void setSerialValue(YangString serialValue) throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "serial",
            serialValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "serial",
     * using a String value.
     * @param serialValue used during instantiation.
     */
    public void setSerialValue(String serialValue) throws JNCException {
        setSerialValue(new YangString(serialValue));
    }

    /**
     * Unsets the value for child leaf "serial".
     */
    public void unsetSerialValue() throws JNCException {
        delete("serial");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "serial" leaf will not have a value.
     */
    public void addSerial() throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "serial",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "serial" with operation "replace".
     */
    public void markSerialReplace() throws JNCException {
        markLeafReplace("serial");
    }

    /**
     * Marks the leaf "serial" with operation "merge".
     */
    public void markSerialMerge() throws JNCException {
        markLeafMerge("serial");
    }

    /**
     * Marks the leaf "serial" with operation "create".
     */
    public void markSerialCreate() throws JNCException {
        markLeafCreate("serial");
    }

    /**
     * Marks the leaf "serial" with operation "delete".
     */
    public void markSerialDelete() throws JNCException {
        markLeafDelete("serial");
    }

    /* Access methods for optional leaf child: "lastRebootTime". */

    /**
     * Gets the value for child leaf "lastRebootTime".
     * @return The value of the leaf.
     */
    public YangUInt32 getLastRebootTimeValue() throws JNCException {
        return (YangUInt32)getValue("lastRebootTime");
    }

    /**
     * Sets the value for child leaf "lastRebootTime",
     * using instance of generated typedef class.
     * @param lastRebootTimeValue The value to set.
     * @param lastRebootTimeValue used during instantiation.
     */
    public void setLastRebootTimeValue(YangUInt32 lastRebootTimeValue)
            throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "lastRebootTime",
            lastRebootTimeValue,
            childrenNames());
    }

    /**
     * Sets the value for child leaf "lastRebootTime",
     * using Java primitive values.
     * @param lastRebootTimeValue used during instantiation.
     */
    public void setLastRebootTimeValue(long lastRebootTimeValue)
            throws JNCException {
        setLastRebootTimeValue(new YangUInt32(lastRebootTimeValue));
    }

    /**
     * Sets the value for child leaf "lastRebootTime",
     * using a String value.
     * @param lastRebootTimeValue used during instantiation.
     */
    public void setLastRebootTimeValue(String lastRebootTimeValue)
            throws JNCException {
        setLastRebootTimeValue(new YangUInt32(lastRebootTimeValue));
    }

    /**
     * Unsets the value for child leaf "lastRebootTime".
     */
    public void unsetLastRebootTimeValue() throws JNCException {
        delete("lastRebootTime");
    }

    /**
     * This method is used for creating a subtree filter.
     * The added "lastRebootTime" leaf will not have a value.
     */
    public void addLastRebootTime() throws JNCException {
        setLeafValue(Devmgt.NAMESPACE,
            "lastRebootTime",
            null,
            childrenNames());
    }

    /**
     * Marks the leaf "lastRebootTime" with operation "replace".
     */
    public void markLastRebootTimeReplace() throws JNCException {
        markLeafReplace("lastRebootTime");
    }

    /**
     * Marks the leaf "lastRebootTime" with operation "merge".
     */
    public void markLastRebootTimeMerge() throws JNCException {
        markLeafMerge("lastRebootTime");
    }

    /**
     * Marks the leaf "lastRebootTime" with operation "create".
     */
    public void markLastRebootTimeCreate() throws JNCException {
        markLeafCreate("lastRebootTime");
    }

    /**
     * Marks the leaf "lastRebootTime" with operation "delete".
     */
    public void markLastRebootTimeDelete() throws JNCException {
        markLeafDelete("lastRebootTime");
    }

    /**
     * Support method for addChild.
     * Adds a child to this object.
     * 
     * @param child The child to add
     */
    public void addChild(Element child) {
        super.addChild(child);
    }

}
